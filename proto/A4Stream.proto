package a4.io;

import "google/protobuf/descriptor.proto";

import "MetadataExtension.proto";

message A4StreamHeader
{
    optional int32 CLASS_ID = 100;
    required int32 a4_version = 1;
    optional string description = 2;
    optional int32 content_class_id = 3;
    optional int32 metadata_class_id = 4;
    // if metadata_refers_forward is true, metadata are referring 
    // to objects that follow them instead of precede them
    optional bool metadata_refers_forward = 5 [default=false]; 
    // File descriptors necessary to read content or metadata
    repeated google.protobuf.FileDescriptorProto file_descriptors = 6;
}

message A4StreamFooter
{
    optional int32 CLASS_ID = 101;
    required int64 size = 1; // number of bytes written before the footer
    optional int32 content_count = 2; // number of 'content' events
    repeated int64 metadata_offsets = 3; // position of the 'backward-facing' metadata messages in this file
    optional bool metadata_refers_forward = 5 [default=false]; 
}

message A4StartCompressedSection
{
    optional int32 CLASS_ID = 102;
    enum Compression {
        ZLIB = 0;
        GZIP = 1;
        BZIP2 = 2;
        SNAPPY = 3;
    }
    optional Compression compression = 1;
}

message A4EndCompressedSection
{
    optional int32 CLASS_ID = 103;
}

message A4Proto
{
    optional int32 CLASS_ID = 105;
    
    optional google.protobuf.FileDescriptorProto file_descriptor = 1;
}

message TestEvent
{
    optional int32 CLASS_ID = 300;
    optional int32 event_number = 1;
    optional double event_data = 2;
}

message TestRunLB
{
    optional int32 run = 1;
    optional int32 lumiblock = 2;
}

message TestMetaData
{
    optional int32 CLASS_ID = 301;
    optional int32 meta_data = 1 [(merge)=MERGE_ADD];
}

message TestMergeMetaDataStatic
{
    optional int32 CLASS_ID = 302;
    optional int32 meta_data = 1 [(merge)=MERGE_ADD];
}

message TestMergeMetaData
{
    optional int32 CLASS_ID = 302;
    optional int32 meta_data = 1 [(merge)=MERGE_ADD];
    repeated TestRunLB lumiblock = 2 [(merge)=MERGE_UNION];
    repeated int32 run = 9 [(merge)=MERGE_UNION];
    repeated int32 period = 3 [(merge)=MERGE_UNION];
    optional bool simulation = 4 [(merge)=MERGE_BLOCK_IF_DIFFERENT];
    repeated string comments = 5 [(merge)=MERGE_APPEND];
    optional string tags = 6 [(merge)=MERGE_ADD];
    optional double efficiency = 7 [(merge)=MERGE_MULTIPLY];
    optional bool error = 8 [(merge)=MERGE_AND];
}
